"""
Tests for app/routers/ai.py — AI chat and execute endpoints.

Covers:
- POST /ai/chat — chat endpoint with mocked AIService and ConversationService
- POST /ai/execute — execute action (confirmed and cancelled cases)
- Follow-up context handling
- Topic ID generation
"""
import uuid
from unittest.mock import MagicMock, patch

import pytest
from fastapi.testclient import TestClient

from app.hotel.models.ontology import Employee, EmployeeRole
from app.main import app
from app.routers.ai import get_conversation_service
from app.security.auth import create_access_token, get_password_hash
from app.services.conversation_service import (
    ConversationMessage,
    ConversationService,
    MessageContext,
)


# ==================== Fixtures ====================

@pytest.fixture
def manager_user(db_session):
    """Create a manager user in the DB and return the ORM object."""
    user = Employee(
        username="mgr_ai",
        password_hash=get_password_hash("123456"),
        name="AI Manager",
        role=EmployeeRole.MANAGER,
        is_active=True,
    )
    db_session.add(user)
    db_session.commit()
    db_session.refresh(user)
    return user


@pytest.fixture
def manager_token(manager_user):
    return create_access_token(manager_user.id, manager_user.role)


@pytest.fixture
def manager_auth_headers(manager_token):
    return {"Authorization": f"Bearer {manager_token}"}


@pytest.fixture
def mock_conv_service():
    """Return a fully-mocked ConversationService."""
    svc = MagicMock(spec=ConversationService)
    svc.generate_topic_id.return_value = "abcd1234"
    svc.get_context_messages.return_value = []
    svc.save_message_pair.return_value = (
        ConversationMessage(
            id=str(uuid.uuid4()),
            timestamp="2025-01-01T00:00:00",
            role="user",
            content="test",
        ),
        ConversationMessage(
            id=str(uuid.uuid4()),
            timestamp="2025-01-01T00:00:01",
            role="assistant",
            content="response",
        ),
    )
    return svc


@pytest.fixture(autouse=True)
def _override_conv_service(mock_conv_service):
    """Override the conversation service dependency for all tests in this module."""
    app.dependency_overrides[get_conversation_service] = lambda: mock_conv_service
    yield
    app.dependency_overrides.pop(get_conversation_service, None)


# ==================== POST /ai/chat ====================

class TestAiChat:
    """Tests for POST /ai/chat."""

    @patch("app.routers.ai.AIService")
    def test_chat_basic(self, MockAIService, client, manager_auth_headers, mock_conv_service):
        """Basic chat returns 200 with expected response shape."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "Hello, how can I help?",
            "suggested_actions": [],
            "context": {},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "hello"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["message"] == "Hello, how can I help?"
        assert isinstance(data["suggested_actions"], list)
        assert "message_id" in data
        assert "topic_id" in data

    @patch("app.routers.ai.AIService")
    def test_chat_generates_topic_id_when_absent(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """When no topic_id in request or result, a new one is generated."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "hello"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        # topic_id should be the one generated by the mocked service
        assert data["topic_id"] == "abcd1234"
        mock_conv_service.generate_topic_id.assert_called_once()

    @patch("app.routers.ai.AIService")
    def test_chat_uses_result_topic_id(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """When result contains topic_id, that takes precedence."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
            "topic_id": "from-result",
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "hello"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        assert resp.json()["topic_id"] == "from-result"

    @patch("app.routers.ai.AIService")
    def test_chat_uses_request_topic_id(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """When request has topic_id and result does not, request topic_id is used."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "follow up", "topic_id": "existing-topic"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        assert resp.json()["topic_id"] == "existing-topic"

    @patch("app.routers.ai.AIService")
    def test_chat_with_topic_id_fetches_context(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """When topic_id is provided, context messages are fetched for that topic."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "follow up", "topic_id": "t123"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        # Verify context messages were fetched with topic_id
        mock_conv_service.get_context_messages.assert_called_once()
        call_kwargs = mock_conv_service.get_context_messages.call_args
        assert call_kwargs.kwargs.get("topic_id") == "t123" or call_kwargs[1].get("topic_id") == "t123"

    @patch("app.routers.ai.AIService")
    def test_chat_without_topic_id_fetches_recent_context(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Without topic_id, recent context messages are fetched."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "hello"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        mock_conv_service.get_context_messages.assert_called_once()

    @patch("app.routers.ai.AIService")
    def test_chat_follow_up_context_from_request(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Frontend-provided follow_up_context overrides extracted context."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        follow_up = {
            "action_type": "create_reservation",
            "collected_fields": {"guest_name": "Zhang"},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "room 101", "follow_up_context": follow_up},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        # Verify process_message was called with the follow_up_context
        call_kwargs = instance.process_message.call_args
        assert call_kwargs.kwargs.get("follow_up_context") == follow_up

    @patch("app.routers.ai.AIService")
    def test_chat_follow_up_context_from_history(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """When topic_id is provided and history has follow_up context, it is extracted."""
        # Simulate assistant message with follow_up context in context field
        assistant_msg = ConversationMessage(
            id="msg-1",
            timestamp="2025-01-01T00:00:00",
            role="assistant",
            content="Please provide room type",
            context=MessageContext(
                topic_id="t-follow",
                is_followup=False,
            ),
        )
        # Simulate the context dict attribute
        assistant_msg.context = type("Ctx", (), {
            "topic_id": "t-follow",
            "is_followup": False,
            "parent_message_id": None,
        })()
        # Patch get_context_messages to return messages with follow-up context
        # The router accesses msg.context as a dict check — we need to simulate that
        # The code does: `context_data = msg.context` then `isinstance(context_data, dict)`
        # So we need msg.context to be a dict for the follow-up extraction
        mock_msg = MagicMock()
        mock_msg.role = "assistant"
        mock_msg.content = "Please provide guest name"
        mock_msg.context = {
            "action_type": "walkin_checkin",
            "collected_fields": {"room_number": "101"},
            "follow_up": True,
        }
        mock_conv_service.get_context_messages.return_value = [mock_msg]

        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "Zhang San", "topic_id": "t-follow"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        # Verify follow_up_context was extracted from history
        call_kwargs = instance.process_message.call_args
        fuc = call_kwargs.kwargs.get("follow_up_context")
        assert fuc is not None
        assert fuc["action_type"] == "walkin_checkin"

    @patch("app.routers.ai.AIService")
    def test_chat_with_query_result(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Query result and context are saved and returned in response."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "Found 3 rooms",
            "suggested_actions": [],
            "context": {"type": "query"},
            "query_result": {"rows": [{"room": "101"}], "total": 1},
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "show rooms"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["query_result"] is not None
        assert data["query_result"]["total"] == 1

    @patch("app.routers.ai.AIService")
    def test_chat_with_requires_confirmation(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Requires confirmation field is passed through."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "Confirm check-in?",
            "suggested_actions": [
                {
                    "action_type": "walkin_checkin",
                    "entity_type": "StayRecord",
                    "params": {"room_number": "101"},
                    "description": "Walk-in check-in",
                    "requires_confirmation": True,
                }
            ],
            "context": {},
            "requires_confirmation": True,
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "checkin room 101"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["requires_confirmation"] is True

    @patch("app.routers.ai.AIService")
    def test_chat_saves_message_pair(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Chat saves message pair via ConversationService."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "Hi there",
            "suggested_actions": [],
            "context": {},
        }

        client.post(
            "/ai/chat",
            json={"content": "hello"},
            headers=manager_auth_headers,
        )

        mock_conv_service.save_message_pair.assert_called_once()

    @patch("app.routers.ai.AIService")
    def test_chat_with_language(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Language parameter is forwarded to process_message."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "ok",
            "suggested_actions": [],
            "context": {},
        }

        client.post(
            "/ai/chat",
            json={"content": "hello", "language": "en"},
            headers=manager_auth_headers,
        )

        call_kwargs = instance.process_message.call_args
        assert call_kwargs.kwargs.get("language") == "en"

    def test_chat_requires_auth(self, client):
        """Unauthenticated request returns 401 or 403."""
        resp = client.post("/ai/chat", json={"content": "hello"})
        assert resp.status_code in (401, 403)

    @patch("app.routers.ai.AIService")
    def test_chat_with_candidates(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Candidates field is passed through in response."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "Multiple matches found",
            "suggested_actions": [],
            "context": {},
            "candidates": [{"id": 1, "name": "Zhang"}],
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "find guest zhang"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["candidates"] is not None
        assert len(data["candidates"]) == 1

    @patch("app.routers.ai.AIService")
    def test_chat_with_follow_up_in_response(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Follow-up info in result is passed through."""
        instance = MockAIService.return_value
        instance.process_message.return_value = {
            "message": "Need more info",
            "suggested_actions": [],
            "context": {},
            "follow_up": {
                "action_type": "create_reservation",
                "message": "Please provide check-in date",
                "missing_fields": [],
                "collected_fields": {"guest_name": "Zhang"},
            },
        }

        resp = client.post(
            "/ai/chat",
            json={"content": "reserve a room"},
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["follow_up"] is not None
        assert data["follow_up"]["action_type"] == "create_reservation"


# ==================== POST /ai/execute ====================

class TestAiExecute:
    """Tests for POST /ai/execute."""

    @patch("app.routers.ai.AIService")
    def test_execute_confirmed(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Confirmed action is executed and result returned."""
        instance = MockAIService.return_value
        instance.execute_action.return_value = {
            "success": True,
            "message": "Check-in completed",
        }

        resp = client.post(
            "/ai/execute",
            json={
                "action": {
                    "action_type": "walkin_checkin",
                    "entity_type": "StayRecord",
                    "params": {"room_number": "101"},
                    "description": "Walk-in check-in",
                    "requires_confirmation": True,
                },
                "confirmed": True,
            },
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["success"] is True
        assert data["message"] == "Check-in completed"
        instance.execute_action.assert_called_once()

    @patch("app.routers.ai.AIService")
    def test_execute_cancelled(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Cancelled action returns cancellation message without executing."""
        resp = client.post(
            "/ai/execute",
            json={
                "action": {
                    "action_type": "walkin_checkin",
                    "entity_type": "StayRecord",
                    "params": {},
                    "description": "Walk-in check-in",
                    "requires_confirmation": True,
                },
                "confirmed": False,
            },
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert "取消" in data["message"]
        # Should save cancellation message pair
        mock_conv_service.save_message_pair.assert_called_once()

    @patch("app.routers.ai.AIService")
    def test_execute_saves_result_message(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Successful execution saves a message pair."""
        instance = MockAIService.return_value
        instance.execute_action.return_value = {
            "success": True,
            "message": "Done",
        }

        client.post(
            "/ai/execute",
            json={
                "action": {
                    "action_type": "mark_room_clean",
                    "entity_type": "Room",
                    "params": {"room_number": "101"},
                    "description": "Mark clean",
                    "requires_confirmation": True,
                },
                "confirmed": True,
            },
            headers=manager_auth_headers,
        )

        mock_conv_service.save_message_pair.assert_called_once()

    @patch("app.routers.ai.AIService")
    def test_execute_error_returns_error_response(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Execution failure returns error response (does not raise 500)."""
        instance = MockAIService.return_value
        instance.execute_action.side_effect = RuntimeError("DB connection failed")

        resp = client.post(
            "/ai/execute",
            json={
                "action": {
                    "action_type": "walkin_checkin",
                    "entity_type": "StayRecord",
                    "params": {},
                    "description": "Check-in",
                    "requires_confirmation": True,
                },
                "confirmed": True,
            },
            headers=manager_auth_headers,
        )

        assert resp.status_code == 200
        data = resp.json()
        assert data["success"] is False
        assert "失败" in data["message"] or "error" in data.get("error", "").lower() or "DB connection failed" in data.get("error", "")

    def test_execute_requires_auth(self, client):
        """Unauthenticated request returns 401 or 403."""
        resp = client.post(
            "/ai/execute",
            json={
                "action": {
                    "action_type": "test",
                    "entity_type": "Room",
                    "params": {},
                    "description": "test",
                },
                "confirmed": True,
            },
        )
        assert resp.status_code in (401, 403)

    @patch("app.routers.ai.AIService")
    def test_execute_uses_description_from_action(
        self, MockAIService, client, manager_auth_headers, mock_conv_service
    ):
        """Execution uses action description for the saved message content."""
        instance = MockAIService.return_value
        instance.execute_action.return_value = {
            "success": True,
            "message": "Completed",
        }

        client.post(
            "/ai/execute",
            json={
                "action": {
                    "action_type": "create_task",
                    "entity_type": "Task",
                    "params": {},
                    "description": "Create cleaning task",
                    "requires_confirmation": True,
                },
                "confirmed": True,
            },
            headers=manager_auth_headers,
        )

        # Check that save_message_pair was called with a user_content containing the description
        call_args = mock_conv_service.save_message_pair.call_args
        user_content = call_args.kwargs.get("user_content") or call_args[1].get("user_content", call_args[0][1] if len(call_args[0]) > 1 else "")
        assert "Create cleaning task" in user_content
