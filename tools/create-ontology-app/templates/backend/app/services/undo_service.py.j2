"""
Undo service â€” operation rollback.

Generic undo infrastructure. Domain-specific rollback logic should be
implemented as undo handlers registered by the domain plugin.
"""
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any, Callable
from sqlalchemy.orm import Session
import uuid
import json
import logging

from app.models.snapshots import OperationSnapshot, OperationType
from app.services.event_bus import event_bus, Event
from app.models.events import EventType, OperationUndoneData

logger = logging.getLogger(__name__)


class UndoService:
    """Operation undo service."""

    UNDO_WINDOW_HOURS = 24

    def __init__(self, db: Session, event_publisher: Callable[[Event], None] = None):
        self.db = db
        self._publish_event = event_publisher or event_bus.publish

    def create_snapshot(
        self,
        operation_type: OperationType,
        entity_type: str,
        entity_id: int,
        before_state: Dict[str, Any],
        after_state: Dict[str, Any],
        operator_id: int,
        related_snapshots: List[str] = None
    ) -> OperationSnapshot:
        """Create an operation snapshot for undo support."""
        snapshot = OperationSnapshot(
            snapshot_uuid=str(uuid.uuid4()),
            operation_type=operation_type.value if isinstance(operation_type, OperationType) else operation_type,
            operator_id=operator_id,
            operation_time=datetime.now(),
            entity_type=entity_type,
            entity_id=entity_id,
            before_state=json.dumps(before_state, default=str, ensure_ascii=False),
            after_state=json.dumps(after_state, default=str, ensure_ascii=False),
            related_snapshots=json.dumps(related_snapshots or []),
            expires_at=datetime.now() + timedelta(hours=self.UNDO_WINDOW_HOURS)
        )
        self.db.add(snapshot)
        self.db.flush()

        logger.info(f"Created snapshot {snapshot.snapshot_uuid} for {operation_type}")
        return snapshot

    def get_snapshot(self, snapshot_uuid: str) -> Optional[OperationSnapshot]:
        return self.db.query(OperationSnapshot).filter(
            OperationSnapshot.snapshot_uuid == snapshot_uuid
        ).first()

    def get_snapshot_by_id(self, snapshot_id: int) -> Optional[OperationSnapshot]:
        return self.db.query(OperationSnapshot).filter(
            OperationSnapshot.id == snapshot_id
        ).first()

    def get_undoable_operations(
        self,
        entity_type: str = None,
        entity_id: int = None,
        limit: int = 20
    ) -> List[OperationSnapshot]:
        query = self.db.query(OperationSnapshot).filter(
            OperationSnapshot.is_undone == False,
            OperationSnapshot.expires_at > datetime.now()
        )
        if entity_type:
            query = query.filter(OperationSnapshot.entity_type == entity_type)
        if entity_id:
            query = query.filter(OperationSnapshot.entity_id == entity_id)

        return query.order_by(OperationSnapshot.operation_time.desc()).limit(limit).all()

    def get_undo_history(self, limit: int = 50) -> List[OperationSnapshot]:
        return self.db.query(OperationSnapshot).filter(
            OperationSnapshot.is_undone == True
        ).order_by(OperationSnapshot.undone_time.desc()).limit(limit).all()

    def can_undo(self, snapshot: OperationSnapshot) -> tuple[bool, str]:
        if not snapshot:
            return False, "Snapshot not found"
        if snapshot.is_undone:
            return False, "Operation already undone"
        if snapshot.expires_at < datetime.now():
            return False, "Undo window expired"
        return True, ""

    def undo_operation(self, snapshot_uuid: str, operator_id: int) -> Dict[str, Any]:
        snapshot = self.get_snapshot(snapshot_uuid)

        can_undo, reason = self.can_undo(snapshot)
        if not can_undo:
            raise ValueError(reason)

        result = self._execute_rollback(snapshot)

        snapshot.is_undone = True
        snapshot.undone_time = datetime.now()
        snapshot.undone_by = operator_id

        self._publish_event(Event(
            event_type=EventType.OPERATION_UNDONE,
            timestamp=datetime.now(),
            data=OperationUndoneData(
                snapshot_id=snapshot.snapshot_uuid,
                operation_type=snapshot.operation_type,
                entity_type=snapshot.entity_type,
                entity_id=snapshot.entity_id,
                undone_by=operator_id
            ).to_dict(),
            source="undo_service"
        ))

        logger.info(f"Undone operation {snapshot.snapshot_uuid}")
        return result

    def _execute_rollback(self, snapshot: OperationSnapshot) -> Dict[str, Any]:
        """Execute rollback logic.

        TODO: Implement domain-specific rollback handlers.
        Override this method or register rollback handlers for your domain operations.
        """
        raise ValueError(f"No rollback handler for operation type: {snapshot.operation_type}")
